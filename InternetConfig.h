/* ¥¥¥Start Header¥¥¥ *//* File:         InternetConfig.h * Generated by: 1.0d6 * For:          IC 2.0 * On:           Wednesday, 6 May 1998, 23:12:40 *  * This file is part of the Internet Configuration system and * is placed in the public domain for the benefit of all. *//* ¥¥¥End Header¥¥¥ *//*	IMPORTANT NOTES ABOUT THE C HEADERS	-----------------------------------		o 	Pascal "var" parameters are converted from "var x : y" to "y *x".  This		means that when you see the parameter "y *x" you should be aware that		you *cannot pass in nil*.  In future this restriction may be eased,		especially for the attr parameter to ICGetPref.  Parameters where nil		is legal are declared using the explicit pointer type, ie "yPtr x".	o 	Strings are *Pascal* strings.  This means that they must be word aligned.		MPW and Think C do this automatically.  The last time I check, Metrowerks		C does not.  If it still doesn't, then IMHO it's a bug in their compiler		and you should report it to them.  [IC 1.4 and later no longer require		word aligned strings.  You can ignore this warning if you require IC 1.4		or greater.]	o 	The canonical Internet Config interface is defined in Pascal.  If there is a		conflict between these headers and the Pascal interfaces, the Pascal should		take precedence.  Please let me know if you find any problems.*//* ********************************************************************************* */#ifndef __INTERNETCONFIG__#define __INTERNETCONFIG__#ifndef __TYPES__#include <Types.h>#endif#ifndef __FILES__#include <Files.h>#endif#ifndef __ALIASES__#include <Aliases.h>#endif#ifndef __COMPONENTS__#include <Components.h>#endif/* ********************************************************************************* */#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif//#if PRAGMA_ALIGN_SUPPORTED//#pragma options align=mac68k//#endif/* ********************************************************************************* */enum {	icPrefNotFoundErr = -666,			/* preference not found (duh!) */	icPermErr = -667,					/* cannot set preference */	icPrefDataErr = -668,				/* problem with preference data */	icInternalErr = -669,				/* hmm, this is not good */	icTruncatedErr = -670,				/* more data was present than was returned */	icNoMoreWritersErr = -671,			/* you cannot begin a write session because someone else is already doing it */	icNothingToOverrideErr = -672,		/* no component for the override component to capture */	icNoURLErr = -673,					/* no URL found */	icConfigNotFoundErr = -674,			/* no configuration was found */	icConfigInappropriateErr = -675,	/* incorrect manufacturer code */	icProfileNotFoundErr = -676,		/* profile not found */	icTooManyProfilesErr = -677			/* too many profiles in database */};enum {	ICattr_no_change = 0xFFFFFFFFL,				/* supply this to ICSetPref to tell it not to change the attributes */	ICattr_locked_bit = 0,						/* bits in the preference attributes */	ICattr_locked_mask = 0x00000001L,			/* masks for the above */	ICattr_volatile_bit = 1,	ICattr_volatile_mask = 0x00000002L,	icNoUserInteraction_bit = 0,	icNoUserInteraction_mask = 0x00000001L};#define ICfiletype 'ICAp'#define ICcreator 'ICAp'#define ICdefault_file_name "\pInternet Preferences"	/* default file name, for internal use, overridden by a component resource */struct ICDirSpec {						/* a record that specifies a folder */	short vRefNum;	long dirID;};typedef struct ICDirSpec ICDirSpec;typedef ICDirSpec ICDirSpecArray[4];	/* an array of the above */typedef ICDirSpec *ICDirSpecArrayPtr;	/* a pointer to that array */typedef long ICAttr;					/* type for preference attributes */typedef long ICError;					/* type for error codes */typedef Ptr ICInstance;					/* opaque type for preference reference */enum {	icNoPerm = 0,	icReadOnlyPerm = 1,	icReadWritePerm = 2};typedef unsigned char ICPerm;struct ICConfigRef {	OSType manufacturer;	/* other private data follows */};typedef struct ICConfigRef ICConfigRef, *ICConfigRefPtr, **ICConfigRefHandle;enum {	kICNilProfileID = 0};typedef long ICProfileID, *ICProfileIDPtr;enum {	kICEditPreferenceEventClass = 'ICAp',	kICEditPreferenceEvent = 'ICAp',	keyICEditPreferenceDestination = 'dest'};/* ¥¥¥Start ICKeys.h¥¥¥ */#define kICRealName "\pRealName"	/* PString -- real name of user */#define kICEmail "\pEmail"	/* PString -- user@host.domain, email address of user, ie return address */#define kICMailAccount "\pMailAccount"	/* PString -- user@host.domain, account from which to fetch mail */#define kICMailPassword "\pMailPassword"	/* PString -- scrambled, password for MailAccount */#define kICNewsAuthUsername "\pNewsAuthUsername"	/* PString -- user name for authorised news servers */#define kICNewsAuthPassword "\pNewsAuthPassword"	/* PString -- scrambled, password for NewsAuthUsername */#define kICArchiePreferred "\pArchiePreferred"	/* PString -- formatted, preferred Archie server */#define kICArchieAll "\pArchieAll"	/* STR# -- formatted, list of Archie servers */#define kICUMichPreferred "\pUMichPreferred"	/* PString -- formatted, preferred UMich server */#define kICUMichAll "\pUMichAll"	/* STR# -- formatted, list of UMich servers */#define kICInfoMacPreferred "\pInfoMacPreferred"	/* PString -- formatted, preferred Info-Mac server */#define kICInfoMacAll "\pInfoMacAll"	/* STR# -- formatted, list of Info-Mac servers */#define kICPhHost "\pPhHost"	/* PString -- host.domain, default Ph server */#define kICWhoisHost "\pWhoisHost"	/* PString -- host.domain, default whois server */#define kICFingerHost "\pFingerHost"	/* PString -- host.domain, default finger server */#define kICFTPHost "\pFTPHost"	/* PString -- host.domain, default FTP server */#define kICTelnetHost "\pTelnetHost"	/* PString -- host.domain, default Telnet address */#define kICSMTPHost "\pSMTPHost"	/* PString -- host.domain, SMTP server */#define kICNNTPHost "\pNNTPHost"	/* PString -- host.domain, NNTP server */#define kICGopherHost "\pGopherHost"	/* PString -- host.domain, default Gopher server */#define kICLDAPServer "\pLDAPServer"	/* PString -- host.domain */#define kICLDAPSearchbase "\pLDAPSearchbase"	/* PString -- string LDAP thing */#define kICWWWHomePage "\pWWWHomePage"	/* PString -- URL, users default WWW page */#define kICWAISGateway "\pWAISGateway"	/* PString -- no idea */#define kICListFont "\pListFont"	/* ICFontRecord -- font used for lists of items (eg news article lists) */#define kICScreenFont "\pScreenFont"	/* ICFontRecord -- font used for monospaced text (eg news articles) */#define kICDocumentFont "\pDocumentFont"	/* ICFontRecord -- font used for proportional text */#define kICPrinterFont "\pPrinterFont"	/* ICFontRecord -- font used to print ScreenFont */#define kICDownloadFolder "\pDownloadFolder"	/* ICFileSpec -- where to put newly downloaded files */#define kICSignature "\pSignature"	/* TEXT -- append to news and mail messages */#define kICOrganization "\pOrganization"	/* PString -- for X-Organization string */#define kICPlan "\pPlan"	/* TEXT -- default response for finger servers */#define kICQuotingString "\pQuotingString"	/* PString -- used to quote responses in news and mail */#define kICMailHeaders "\pMailHeaders"	/* TEXT -- extra headers for mail messages */#define kICNewsHeaders "\pNewsHeaders"	/* TEXT -- extra headers for news messages */#define kICMapping "\pMapping"	/* ICMapEntries -- file type mapping, see documentation */#define kICCharacterSet "\pCharacterSet"	/* ICCharTable -- Mac-to-Net and Net-to-Mac character translation */#define kICHelper "\pHelper¥"	/* ICAppSpec -- helpers for URL schemes */#define kICServices "\pServices"	/* ICServices -- TCP and IP port-to-name mapping */#define kICNewMailFlashIcon "\pNewMailFlashIcon"	/* Boolean -- how to announce new mail */#define kICNewMailDialog "\pNewMailDialog"	/* Boolean */#define kICNewMailPlaySound "\pNewMailPlaySound"	/* Boolean */#define kICNewMailSoundName "\pNewMailSoundName"	/* PString */#define kICWebBackgroundColour "\pWebBackgroundColour"	/* RGBColor -- background colour for web pages */#define kICNoProxyDomains "\pNoProxyDomains"	/* STR# -- list of domains not to be proxied */#define kICUseSocks "\pUseSocks"	/* Boolean */#define kICSocksHost "\pSocksHost"	/* PString -- host.domain, remember that host.domain format allows ":port" and " port" */#define kICUseHTTPProxy "\pUseHTTPProxy"	/* Boolean */#define kICHTTPProxyHost "\pHTTPProxyHost"	/* PString -- host.domain */#define kICUseGopherProxy "\pUseGopherProxy"	/* Boolean */#define kICGopherProxy "\pGopherProxy"	/* PString -- host.domain, see note in Prog Docs */#define kICUseFTPProxy "\pUseFTPProxy"	/* Boolean */#define kICFTPProxyHost "\pFTPProxyHost"	/* PString -- host.domain */#define kICFTPProxyUser "\pFTPProxyUser"	/* PString -- first level FTP proxy authorisation */#define kICFTPProxyPassword "\pFTPProxyPassword"	/* PString -- scrambled, password for FTPProxyUser */#define kICFTPProxyAccount "\pFTPProxyAccount"	/* PString -- second level FTP proxy authorisation */#define kICUsePassiveFTP "\pUsePassiveFTP"	/* Boolean -- use PASV command for FTP transfers */#define kICSnailMailAddress "\pSnailMailAddress"	/* TEXT -- preferred mailing address */#define kICMacSearchHost "\pMacSearchHost"	/* PString -- host for MacSearch queries */#define kICWebSearchPagePrefs "\pWebSearchPagePrefs"	/* PString -- URL, users default search page */#define kICWebTextColor "\pWebTextColor"	/* RGBColor -- colour for normal text */#define kICWebReadColor "\p646F6777¥WebReadColor"	/* RGBColor -- colour for read links */#define kICWebUnreadColor "\p646F6777¥WebUnreadColor"	/* RGBColor -- colour for unread links */#define kICWebUnderlineLinks "\p646F6777¥WebUnderlineLinks"	/* Boolean -- whether to underline links */#define kICNTPHost "\pNTPHost"	/* PString -- host.domain, Network Time Protocol (NTP) */#define kICIRCHost "\pIRCHost"	/* PString -- host.domain, Internet Relay Chat server */#define kICHelperList "\pHelperList¥"	/* ICAppSpecList -- list of common helpers for URL schemes */#define kICHelperDesc "\pHelperDesc¥"	/* PString -- description for URL scheme *//* ¥¥¥End ICKeys.h¥¥¥ */struct ICFontRecord {	short size;	Style face;	char pad;	Str255 font;};typedef struct ICFontRecord ICFontRecord, *ICFontRecordPtr, **ICFontRecordHandle;struct ICCharTable {	unsigned char net_to_mac[256];	unsigned char mac_to_net[256];};typedef struct ICCharTable ICCharTable, *ICCharTablePtr, **ICCharTableHandle;struct ICAppSpec {	OSType fCreator;	Str63 name;};typedef struct ICAppSpec ICAppSpec, *ICAppSpecPtr, **ICAppSpecHandle;struct ICAppSpecList {	short numberOfItems;	ICAppSpec appSpecs[1];};typedef struct ICAppSpecList ICAppSpecList, *ICAppSpecListPtr, **ICAppSpecListHandle;#if OLDROUTINENAMES		/*	ICFileInfo was originally used to define the format of a key.	That key was removed, but we forgot to remove ICFileInfo.	I hope to remove it entirely, but for the moment it's available	if you define OLDROUTINENAMES.*/struct ICFileInfo {	OSType fType;	OSType fCreator;	Str63 name;};typedef struct ICFileInfo ICFileInfo, *ICFileInfoPtr, **ICFileInfoHandle;#endifstruct ICFileSpec {	Str31 vol_name;	long vol_creation_date;	FSSpec fss;	AliasRecord alias;	/* plus extra data, aliasSize 0 means no alias manager present when			ICFileSpecification was created */};typedef struct ICFileSpec ICFileSpec, *ICFileSpecPtr, **ICFileSpecHandle;enum {	ICfile_spec_header_size = sizeof(ICFileSpec) - sizeof(AliasRecord)};struct ICMapEntry {	short total_length;	short fixed_length;	short version;	OSType file_type;	OSType file_creator;	OSType post_creator;	long flags;	/* variable part starts here */	Str255 extension;	Str255 creator_app_name;	Str255 post_app_name;	Str255 MIME_type;	Str255 entry_name;};typedef struct ICMapEntry ICMapEntry, *ICMapEntryPtr, **ICMapEntryHandle;enum {	ICmap_binary_bit = 0,					/* file should be transfered in binary as opposed to text mode */	ICmap_binary_mask = 0x00000001,	ICmap_resource_fork_bit = 1,			/* the resource fork of the file is significant */	ICmap_resource_fork_mask = 0x00000002,	ICmap_data_fork_bit = 2,				/* the data fork of the file is significant */	ICmap_data_fork_mask = 0x00000004,	ICmap_post_bit = 3,						/* post process using post fields */	ICmap_post_mask = 0x00000008,	ICmap_not_incoming_bit = 4,				/* ignore this mapping for incoming files */	ICmap_not_incoming_mask = 0x00000010,	ICmap_not_outgoing_bit = 5,				/* ignore this mapping for outgoing files */	ICmap_not_outgoing_mask = 0x00000020,	ICmap_fixed_length = 22					/* number in fixed_length field */};struct ICServiceEntry {	Str255 name;	short port;	short flags;};typedef struct ICServiceEntry ICServiceEntry, *ICServiceEntryPtr, **ICServiceEntryHandle;struct ICServices {	short count;	ICServiceEntry services[1];};typedef struct ICServices ICServices, *ICServicesPtr, **ICServicesHandle;enum {	ICservices_tcp_bit = 0,	ICservices_tcp_mask = 0x00000001,	ICservices_udp_bit = 1,	ICservices_udp_mask = 0x00000002	/* both bits can be set, which means the service is both TCP and UDP, eg daytime */};/* ***** Notes Relevant To All API Routines ***** *//*	[r1] Requires IC 1.1 or higher.	[r2] Requires IC 1.2 or higher.	[r3] Requires IC 2.0 or higher.		[c1] You must have specified a configuration before		 calling this routine.	[c2] You must have specified the default configuration		 before calling this routine.	[c3] You do not need to specify a configuration before		 calling this routine.	[b1] You must be inside a Begin/End pair when calling		 this routine.	[b2] You must be inside a Begin/End read/write pair when		 calling this routine.	[b3] You do not need to be inside a Begin/End pair when	 	 calling this routine.	[b4] If you are getting or setting multiple preferences,		 you should make this call inside a Begin/End pair.		 If you do not make this call inside a Begin/End pair,		 the call will automatically do it for you.	[b5] It is illegal to call this routine inside a		 Begin/End pair.*/#ifdef __cplusplusextern "C" {#endif/* ¥¥¥Start ICAPI.h¥¥¥ *//* ***** Starting Up and Shutting Down ***** */pascal ICError ICStart(ICInstance *inst, OSType creator);  /* Call this at application initialisation. Set creator to your application   * creator to allow for future expansion of the IC system. Returns   * inst as a connection to the IC system.   */pascal ICError ICStop(ICInstance inst);  /* [b5]    * Call this at application initialisation, after which inst   * is no longer valid connection to IC.   *//* ***** Specifying a Configuration ***** */pascal ICError ICFindConfigFile(ICInstance inst, short count, ICDirSpecArrayPtr folders)FIVEWORDINLINE(0x2F3C, 6, 2, 0x7000, 0xA82A);  /* [b5]    * Call to configure this connection to IC.   * Set count as the number of valid elements in folders.   * Set folders to a pointer to the folders to search.   * Setting count to 0 and folders to nil is OK.   * Searches the specified folders and then the Preferences folder   * in a unspecified manner.   */pascal ICError ICFindUserConfigFile(ICInstance inst, ICDirSpec *where)FIVEWORDINLINE(0x2F3C, 4, 14, 0x7000, 0xA82A);  /* [r1] [b5]    * Similar to ICFindConfigFile except that it only searches the folder   * specified in where.  If the input parameters are valid the routine   * will always successful configure the instance, creating an   * empty configuration if necessary   * For use with double-clickable preference files.   */pascal ICError ICGeneralFindConfigFile(ICInstance inst, Boolean searchPrefs, Boolean canCreate, short count, ICDirSpecArrayPtr folders)FIVEWORDINLINE(0x2F3C, 10, 30, 0x7000, 0xA82A);  /* [r2] [b5]    * Call to configure this connection to IC.   * This routine acts as a more general replacement for   * ICFindConfigFile and ICFindUserConfigFile.   * Set search_prefs to true if you want it to search the preferences folder.   * Set can_create to true if you want it to be able to create a new config.   * Set count as the number of valid elements in folders.   * Set folders to a pointer to the folders to search.   * Setting count to 0 and folders to nil is OK.   * Searches the specified folders and then optionally the Preferences folder   * in a unspecified manner.   */pascal ICError ICChooseConfig(ICInstance inst)FIVEWORDINLINE(0x2F3C, 0, 33, 0x7000, 0xA82A);  /* [r2] [b5]    * Requests the user to choose a configuration, typically using some   * sort of modal dialog. If the user cancels the dialog the configuration   * state will be unaffected.   */pascal ICError ICChooseNewConfig(ICInstance inst)FIVEWORDINLINE(0x2F3C, 0, 34, 0x7000, 0xA82A);  /* [r2] [b5]    * Requests the user to create a new configuration, typically using some   * sort of modal dialog. If the user cancels the dialog the configuration   * state will be unaffected.   */pascal ICError ICGetConfigName(ICInstance inst, Boolean longname, Str255 name)FIVEWORDINLINE(0x2F3C, 6, 35, 0x7000, 0xA82A);  /* [r2] [c1] [b3]    * Returns a string that describes the current configuration at a user   * level. Set longname to true if you want a long name, up to 255   * characters, or false if you want a short name, typically about 32   * characters.   * The returned string is for user display only. If you rely on the   * exact format of it, you will conflict with any future IC   * implementation that doesn't use explicit preference files.   */pascal ICError ICGetConfigReference(ICInstance inst, ICConfigRefHandle ref)FIVEWORDINLINE(0x2F3C, 4, 31, 0x7000, 0xA82A);  /* [r2] [c1] [b3]    * Returns a self-contained reference to the instance's current   * configuration.   * ref must be a valid non-nil handle and it will be resized to fit the   * resulting data.   */pascal ICError ICSetConfigReference(ICInstance inst, ICConfigRefHandle ref, long flags)FIVEWORDINLINE(0x2F3C, 8, 32, 0x7000, 0xA82A);  /* [r2] [b5]    * Reconfigures the instance using a configuration reference that was   * got using ICGetConfigReference reference. Set the   * icNoUserInteraction_bit in flags if you require that this routine   * not present a modal dialog. Other flag bits are reserved and should   * be set to zero.   * ref must not be nil.   *//* ***** Private Routines ***** *  * If you are calling these routines, you are most probably doing something * wrong.  Please read the documentation for more details. */pascal ICError ICSpecifyConfigFile(ICInstance inst, FSSpec *config)FIVEWORDINLINE(0x2F3C, 4, 3, 0x7000, 0xA82A);  /* [b5]    * For use only by the IC application.   * If you call this routine yourself, you will conflict with any   * future IC implementation that doesn't use explicit preference files.   */pascal ICError ICRefreshCaches(ICInstance inst)FIVEWORDINLINE(0x2F3C, 0, 47, 0x7000, 0xA82A);  /* [r3] [c1] [b3]    * For use only by the IC application.   * If you call this routine yourself, you will conflict with any   * future IC implementation that doesn't use explicit preference files.   *//* ***** Getting Information ***** */pascal ICError ICGetSeed(ICInstance inst, long *seed)FIVEWORDINLINE(0x2F3C, 4, 4, 0x7000, 0xA82A);  /* [c3] [b3]    * Returns the current seed for the IC prefs database.   * This seed changes each time a non-volatile preference is changed.   * You can poll this to determine if any cached preferences change.   */pascal ICError ICGetPerm(ICInstance inst, ICPerm *perm)FIVEWORDINLINE(0x2F3C, 4, 13, 0x7000, 0xA82A);  /* [c3] [b3]    * Returns the access permissions currently associated with this instance.   * While applications normally know what permissions they have,   * this routine is designed for use by override components.   */pascal ICError ICDefaultFileName(ICInstance inst, Str63 name)FIVEWORDINLINE(0x2F3C, 4, 11, 0x7000, 0xA82A);  /* [c3] [b3]    * Returns the default file name for IC preference files.   * Applications should never need to call this routine.   * If you rely on information returned by this routine yourself,   * you may conflict with any future IC implementation that doesn't use   * explicit preference files.   * The component calls this routine to set up the default IC file name.   * This allows this operation to be intercepted by a component that has   * captured us. It currently gets it from the component resource file.   * The glue version is hardwired to "Internet Preferences".   */pascal ICError ICGetComponentInstance(ICInstance inst, ComponentInstance *componentInst);  /* [r3] [c3] [b3]    * Returns noErr and the connection to the IC component,   * if we're using the component.   * Returns badComponenInstance and nil if we're operating with glue.   *//* ***** Reading and Writing Preferences ***** */pascal ICError ICBegin(ICInstance inst, ICPerm perm)FIVEWORDINLINE(0x2F3C, 2, 5, 0x7000, 0xA82A);  /* [c1] [b5]    * Starting reading or writing multiple preferences.   * A call to this must be balanced by a call to ICEnd.   * Do not call WaitNextEvent between these calls.   * The perm specifies whether you intend to read or read/write.   * Only one writer is allowed per instance.   * Note that this may open resource files that are not closed   * until you call ICEnd.   */pascal ICError ICGetPref(ICInstance inst, ConstStr255Param key, ICAttr *attr, Ptr buf, long *size)FIVEWORDINLINE(0x2F3C, 16, 6, 0x7000, 0xA82A);  /* [c1] [b4]    * Reads the preference specified by key from the IC database to the   * buffer pointed to by buf and size.   * key must not be the empty string.   * If buf is nil then no data is returned.   * size must be non-negative.   * attr and size are always set on return. On errors (except icTruncatedErr)   * attr is set to ICattr_no_change and size is set to 0.   * size is the actual size of the data.   * attr is set to the attributes associated with the preference.   * If this routine returns icTruncatedErr then the other returned   * values are valid except that only the first size bytes have been   * return. size is adjusted to reflect the true size of the preference.   * Returns icPrefNotFound if there is no preference for the key.   */pascal ICError ICSetPref(ICInstance inst, ConstStr255Param key, ICAttr attr, Ptr buf, long size)FIVEWORDINLINE(0x2F3C, 16, 7, 0x7000, 0xA82A);  /* [c1] [b4]    * Sets the preference specified by key from the IC database to the   * value pointed to by buf and size.   * key must not be the empty string.   * size must be non-negative.    * If buf is nil then the preference value is not set and size is ignored.   * If buf is not nil then the preference value is set to the size   * bytes pointed to by buf.   * If attr is ICattr_no_change then the preference attributes are not set.   * Otherwise the preference attributes are set to attr.   * Returns icPermErr if the previous ICBegin was passed icReadOnlyPerm.   * Returns icPermErr if current attr is locked, new attr is locked and buf <> nil.   */pascal ICError ICFindPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr *attr, Handle prefh)FIVEWORDINLINE(0x2F3C, 12, 36, 0x7000, 0xA82A);  /* [r2] [c1] [b4]    * This routine effectively replaces ICGetPrefHandle.   * Reads the preference specified by key from the IC database into   * a handle, prefh.   * key must not be the empty string.   * attr is set to the attributes associated with the preference.   * You must set prefh to a non-nil handle before calling this routine.   * If the preference does not exist, icPrefNotFoundErr is returned.   */pascal ICError ICGetPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr *attr, Handle *prefh)FIVEWORDINLINE(0x2F3C, 12, 26, 0x7000, 0xA82A);  /* [r1] [c1] [b4]    * This routine is now obsolete. Use ICFindPrefHandle instead.   * Reads the preference specified by key from the IC database into   * a newly created handle, prefh.   * key must not be the empty string.   * attr is set to the attributes associated with the preference.   * The incoming value of prefh is ignored.   * A new handle is created in the current heap and returned in prefh.   * If the routine returns an error, prefh is set to nil.   * If the preference does not exist, no error is returned and prefh is set   * to an empty handle.   */pascal ICError ICSetPrefHandle(ICInstance inst, ConstStr255Param key, ICAttr attr, Handle prefh)FIVEWORDINLINE(0x2F3C, 12, 27, 0x7000, 0xA82A);  /* [r1] [c1] [b4]    * Sets the preference specified by key from the IC database to the   * value contained in prefh.   * key must not be the empty string.   * If prefh is nil then the preference value is not set.   * If buf is not nil then the preference value is set to the data   * contained in it.   * If attr is ICattr_no_change then the preference attributes are not set.   * Otherwise the preference attributes are set to attr.   * Returns icPermErr if the previous ICBegin was passed icReadOnlyPerm.   * Returns icPermErr if current attr is locked, new attr is locked and prefh <> nil.   */pascal ICError ICCountPref(ICInstance inst, long *count)FIVEWORDINLINE(0x2F3C, 4, 8, 0x7000, 0xA82A);  /* [c1] [b1]    * Counts the total number of preferences.   * If the routine returns an error, count is set to 0.   */pascal ICError ICGetIndPref(ICInstance inst, long index, Str255 key)FIVEWORDINLINE(0x2F3C, 8, 9, 0x7000, 0xA82A);  /* [c1] [b1]    * Returns the key of the index'th preference.   * index must be positive.   * Returns icPrefNotFoundErr if index is greater than the total number of preferences.   * If the routine returns an error, key is undefined.   */pascal ICError ICDeletePref(ICInstance inst, ConstStr255Param key)FIVEWORDINLINE(0x2F3C, 4, 12, 0x7000, 0xA82A);  /* [c1] [b2]    * Deletes the preference specified by key.   * key must not be the empty string.   * Returns icPrefNotFound if the preference specified by key is not present.   */pascal ICError ICEnd(ICInstance inst)FIVEWORDINLINE(0x2F3C, 0, 10, 0x7000, 0xA82A);  /* [c1] [b1]    * Terminates a preference session, as started by ICBegin.   * You must have called ICBegin before calling this routine.   *//* ***** User Interface Stuff ***** */pascal ICError ICEditPreferences(ICInstance inst, ConstStr255Param key)FIVEWORDINLINE(0x2F3C, 4, 15, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Instructs IC to display the user interface associated with editing   * preferences and focusing on the preference specified by key.   * If key is the empty string then no preference should be focused upon.   * You must have specified a configuration before calling this routine.   * You do not need to call ICBegin before calling this routine.   * In the current implementation this launches the IC application   * (or brings it to the front) and displays the window containing   * the preference specified by key.   * It may have a radically different implementation in future   * IC systems.   *//* ***** URL Handling ***** */pascal ICError ICParseURL(ICInstance inst, ConstStr255Param hint, Ptr data, long len, long *selStart, long *selEnd, Handle url)FIVEWORDINLINE(0x2F3C, 24, 16, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Parses a URL out of the specified text and returns it in a canonical form   * in a handle.   * hint indicates the default scheme for URLs of the form "name@address".   * If hint is the empty string then URLs of that form are not allowed.   * data points to the start of the text. It must not be nil.   * len indicates the length of the text. It must be non-negative.   * selStart and selEnd should be passed in as the current selection of   * the text. This selection is given in the same manner as TextEdit,   * ie if selStart = selEnd then there is no selection only an insertion   * point. Also selStart ² selEnd and 0 ² selStart ² len and 0 ² selEnd ² len.   * selStart and selEnd are returned as the bounds of the URL. If the   * routine returns an error then these new boundaries may be   * invalid but they will be close.   * The incoming url handle must not be nil.  The resulting URL is normalised   * and copied into the url handle, which is resized to fit.   */pascal ICError ICLaunchURL(ICInstance inst, ConstStr255Param hint, Ptr data, long len, long *selStart, long *selEnd)FIVEWORDINLINE(0x2F3C, 20, 17, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Parses a URL out of the specified text and feeds it off to the   * appropriate helper.   * hint indicates the default scheme for URLs of the form "name@address".   * If hint is the empty string then URLs of that form are not allowed.   * data points to the start of the text. It must not be nil.   * len indicates the length of the text. It must be non-negative.   * selStart and selEnd should be passed in as the current selection of   * the text. This selection is given in the same manner as TextEdit,   * ie if selStart = selEnd then there is no selection only an insertion   * point. Also selStart ² selEnd and 0 ² selStart ² len and 0 ² selEnd ² len.   * selStart and selEnd are returned as the bounds of the URL. If the   * routine returns an error then these new boundaries may be   * invalid but they will be close.   * The URL is parsed out of the text and passed off to the appropriate   * helper using the GURL AppleEvent.   *//* ***** Mappings Routines ***** *  * Routines for interrogating mappings database. *  * ----- High Level Routines ----- */pascal ICError ICMapFilename(ICInstance inst, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 8, 24, 0x7000, 0xA82A);  /* [r1] [c1] [b4]    * Takes the name of an incoming file and returns the most appropriate   * mappings database entry, based on its extension.   * filename must not be the empty string.   * Returns icPrefNotFoundErr if no suitable entry is found.   */pascal ICError ICMapTypeCreator(ICInstance inst, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 16, 25, 0x7000, 0xA82A);  /* [r1] [c1] [b4]    * Takes the type and creator (and optionally the name) of an outgoing   * file and returns the most appropriate mappings database entry.   * The filename may be either the name of the outgoing file or   * the empty string.   * Returns icPrefNotFoundErr if no suitable entry found.   *//* ----- Mid Level Routines ----- */pascal ICError ICMapEntriesFilename(ICInstance inst, Handle entries, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 28, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Takes the name of an incoming file and returns the most appropriate   * mappings database entry, based on its extension.   * entries must be a handle to a valid IC mappings database preference.   * filename must not be the empty string.   * Returns icPrefNotFoundErr if no suitable entry is found.   */pascal ICError ICMapEntriesTypeCreator(ICInstance inst, Handle entries, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 20, 29, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Takes the type and creator (and optionally the name) of an outgoing   * file and returns the most appropriate mappings database entry.   * entries must be a handle to a valid IC mappings database preference.   * The filename may be either the name of the outgoing file or   * the empty string.   * Returns icPrefNotFoundErr if no suitable entry found.   *//* ----- Low Level Routines ----- */pascal ICError ICCountMapEntries(ICInstance inst, Handle entries, long *count)FIVEWORDINLINE(0x2F3C, 8, 18, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Counts the number of entries in the mappings database.   * entries must be a handle to a valid IC mappings database preference.   * count is set to the number of entries.   */pascal ICError ICGetIndMapEntry(ICInstance inst, Handle entries, long index, long *pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 16, 19, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Gets the index'th entry in the mappings database.   * entries must be a handle to a valid IC mappings database preference.   * index must be in the range from 1 to the number of entries in the database.   * The value of pos is ignored on input. pos is set to the position of   * the index'th entry in the database and is suitable for passing back   * into ICSetMapEntry.   * Does not return any user data associated with the entry.   */pascal ICError ICGetMapEntry(ICInstance inst, Handle entries, long pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 20, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Returns the entry located at position pos in the mappings database.   * entries must be a handle to a valid IC mappings database preference.   * pos should be 0 to get the first entry. To get the subsequent entries, add   * entry.total_size to pos and iterate.   * Does not return any user data associated with the entry.   */pascal ICError ICSetMapEntry(ICInstance inst, Handle entries, long pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 21, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Sets the entry located at position pos in the mappings database.   * entries must be a handle to a valid IC mappings database preference.   * pos should be either a value returned from ICGetIndMapEntry or a value   * calculated using ICGetMapEntry.   * entry is a var parameter purely for stack space reasons. It is not   * modified in any way.   * Any user data associated with the entry is unmodified.   */pascal ICError ICDeleteMapEntry(ICInstance inst, Handle entries, long pos)FIVEWORDINLINE(0x2F3C, 8, 22, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Deletes the mappings database entry at pos.   * entries must be a handle to a valid IC mappings database preference.   * pos should be either a value returned from ICGetIndMapEntry or a value   * calculated using ICGetMapEntry.   * Also deletes any user data associated with the entry.   */pascal ICError ICAddMapEntry(ICInstance inst, Handle entries, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 8, 23, 0x7000, 0xA82A);  /* [r1] [c1] [b3]    * Adds an entry to the mappings database.   * entries must be a handle to a valid IC mappings database preference.   * The entry is added to the end of the entries database.   * No user data is added.   *//* ***** Profile Management Routines ***** */pascal ICError ICGetCurrentProfile(ICInstance inst, ICProfileID *currentID)FIVEWORDINLINE(0x2F3C, 4, 37, 0x7000, 0xA82A);  /* [r3] [c1] [b3]    * Returns the profile ID of the current profile.   */pascal ICError ICSetCurrentProfile(ICInstance inst, ICProfileID newID)FIVEWORDINLINE(0x2F3C, 4, 38, 0x7000, 0xA82A);  /* [r3] [c1] [b3]    * Sets the current profile to the profile specified in newProfile.   */pascal ICError ICCountProfiles(ICInstance inst, long *count)FIVEWORDINLINE(0x2F3C, 4, 39, 0x7000, 0xA82A);  /* [r3] [c1] [b1]    * Returns the total number of profiles.   */pascal ICError ICGetIndProfile(ICInstance inst, long index, ICProfileID *thisID)FIVEWORDINLINE(0x2F3C, 8, 40, 0x7000, 0xA82A);  /* [r3] [c1] [b1]    * Returns the profile ID of the index'th profile.  index must be positive.   * Returns icProfileNotFoundErr if index is greater than the total number   * of profiles.   */pascal ICError ICGetProfileName(ICInstance inst, ICProfileID thisID, Str255 name)FIVEWORDINLINE(0x2F3C, 8, 41, 0x7000, 0xA82A);  /* [r3] [c1] [b3]    * Returns the name of a profile given its ID.  The name may not uniquely   * identify the profile.  [That's what the profile ID is for!]  The name   * is assumed to be in the system script.   */pascal ICError ICSetProfileName(ICInstance inst, ICProfileID thisID, ConstStr255Param name)FIVEWORDINLINE(0x2F3C, 8, 42, 0x7000, 0xA82A);  /* [r3] [c1] [b3]    * This routine sets the name of the specified profile.  Profile names   * need not be unique.  The name should be in the system script.   */pascal ICError ICAddProfile(ICInstance inst, ICProfileID prototypeID, ICProfileID *newID)FIVEWORDINLINE(0x2F3C, 8, 43, 0x7000, 0xA82A);  /* [r3] [c1] [b2]    * If prototypeID = kICNilProfileID, this routine   * creates a default profile, otherwise it creates a   * profile by cloning the prototype profile.  The ID   * of the new profile is returned in newID.   * The new profile will be give a new, unique, name.   * This does not switch to the new profile.   */pascal ICError ICDeleteProfile(ICInstance inst, ICProfileID thisID)FIVEWORDINLINE(0x2F3C, 4, 44, 0x7000, 0xA82A);  /* [r3] [c1] [b2]    * This routine deletes the profile specified by   * thisID.  Attempting to delete the current profile   * or the last profile will return error.   *//* ***** Interrupt Safe Routines ***** */pascal ICError ICRequiresInterruptSafe(ICInstance inst)FIVEWORDINLINE(0x2F3C, 0, 45, 0x7000, 0xA82A);  /* [r3] [c2] [b3]    * You must call this routine before calling GetMapEntryInterruptSafe   * to give IC chance to cache the mappings data in memory.  The only   * way to clear this state is to close the instance.  You can not reconfigure   * the instance after calling this routine.   */pascal ICError ICGetMappingInterruptSafe(ICInstance inst, Ptr *mappingPref, long *mappingPrefSize)FIVEWORDINLINE(0x2F3C, 8, 46, 0x7000, 0xA82A);  /* [r3] [c2] [b3]    * Returns the "Mapping" preference in an interrupt safe fashion.   * The preference returned pointer is valid until the next   * non-interrupt safe call to IC.  Typically this API is used   * by software that needs to map extensions to type and creator   * at interrupt time, eg foreign file systems.   */pascal ICError ICGetSeedInterruptSafe(ICInstance inst, long *seed)FIVEWORDINLINE(0x2F3C, 4, 48, 0x7000, 0xA82A);  /* [r3] [c2] [b3]    * An interrupt safe version of ICGetSeed.   *//* ¥¥¥End ICAPI.h¥¥¥ */#ifdef __cplusplus}#endifenum {	kICComponentType = 'PREF',							/* the component type */	kICComponentSubType = 'ICAp',					 	/* the component subtype */	kICComponentManufacturer = 'JPQE',	kICComponentInterfaceVersion0 = 0x00000000L,		/* IC >= 1.0 */	kICComponentInterfaceVersion1 = 0x00010000L,		/* IC >= 1.1 */	kICComponentInterfaceVersion2 = 0x00020000L,		/* IC >= 1.2 */	kICComponentInterfaceVersion3 = 0x00030000L,		/* IC >= 2.0 */	/* current version number is version 3 */	kICComponentInterfaceVersion = kICComponentInterfaceVersion3};#if OLDROUTINENAMES/*	This definitions are a) very long, and b) don't conform	to Mac OS standards for naming constants, so I've put	them in only if you're using OLDROUTINENAMES.  Please switch	to the new names given above.*/enum {	internetConfigurationComponentType = 'PREF',						/* the component type */	internetConfigurationComponentSubType = 'ICAp',					 	/* the component subtype */	internetConfigurationComponentInterfaceVersion0 = 0x00000000L,		/* IC >= 1.0 */	internetConfigurationComponentInterfaceVersion1 = 0x00010000L,		/* IC >= 1.1 */	internetConfigurationComponentInterfaceVersion2 = 0x00020000L,		/* IC >= 1.2 */	internetConfigurationComponentInterfaceVersion3 = 0x00030000L,		/* IC >= 2.0 */	/* current version number is version 3 */	internetConfigurationComponentInterfaceVersion = internetConfigurationComponentInterfaceVersion3};#endif#if OLDROUTINENAMES/*	The following type is now obsolete.  If you're using it,	please switch to using a ComponentInstance instead.*/typedef ComponentInstance internetConfigurationComponent;#endifenum {/* ¥¥¥Start ICCSelectors.h¥¥¥ */	kICCStart = 0,	kICCStop = 1,	kICCFindConfigFile = 2,	kICCFindUserConfigFile = 14,	kICCGeneralFindConfigFile = 30,	kICCChooseConfig = 33,	kICCChooseNewConfig = 34,	kICCGetConfigName = 35,	kICCGetConfigReference = 31,	kICCSetConfigReference = 32,	kICCSpecifyConfigFile = 3,	kICCRefreshCaches = 47,	kICCGetSeed = 4,	kICCGetPerm = 13,	kICCDefaultFileName = 11,	kICCBegin = 5,	kICCGetPref = 6,	kICCSetPref = 7,	kICCFindPrefHandle = 36,	kICCGetPrefHandle = 26,	kICCSetPrefHandle = 27,	kICCCountPref = 8,	kICCGetIndPref = 9,	kICCDeletePref = 12,	kICCEnd = 10,	kICCEditPreferences = 15,	kICCParseURL = 16,	kICCLaunchURL = 17,	kICCMapFilename = 24,	kICCMapTypeCreator = 25,	kICCMapEntriesFilename = 28,	kICCMapEntriesTypeCreator = 29,	kICCCountMapEntries = 18,	kICCGetIndMapEntry = 19,	kICCGetMapEntry = 20,	kICCSetMapEntry = 21,	kICCDeleteMapEntry = 22,	kICCAddMapEntry = 23,	kICCGetCurrentProfile = 37,	kICCSetCurrentProfile = 38,	kICCCountProfiles = 39,	kICCGetIndProfile = 40,	kICCGetProfileName = 41,	kICCSetProfileName = 42,	kICCAddProfile = 43,	kICCDeleteProfile = 44,	kICCRequiresInterruptSafe = 45,	kICCGetMappingInterruptSafe = 46,	kICCGetSeedInterruptSafe = 48,  kICCFirstSelector = kICCStart,  kICCLastSelector = 48/* ¥¥¥End ICCSelectors.h¥¥¥ */};#ifdef __cplusplusextern "C" {#endif/* ¥¥¥Start ICCAPI.h¥¥¥ *//* ***** Starting Up and Shutting Down ***** */pascal ICError ICCStart(ComponentInstance *inst, OSType creator);/* See comment for ICCStart. */pascal ICError ICCStop(ComponentInstance inst);/* See comment for ICCStop. *//* ***** Specifying a Configuration ***** */pascal ICError ICCFindConfigFile(ComponentInstance inst, short count, ICDirSpecArrayPtr folders)FIVEWORDINLINE(0x2F3C, 6, 2, 0x7000, 0xA82A);/* See comment for ICCFindConfigFile. */pascal ICError ICCFindUserConfigFile(ComponentInstance inst, ICDirSpec *where)FIVEWORDINLINE(0x2F3C, 4, 14, 0x7000, 0xA82A);/* See comment for ICCFindUserConfigFile. */pascal ICError ICCGeneralFindConfigFile(ComponentInstance inst, Boolean searchPrefs, Boolean canCreate, short count, ICDirSpecArrayPtr folders)FIVEWORDINLINE(0x2F3C, 10, 30, 0x7000, 0xA82A);/* See comment for ICCGeneralFindConfigFile. */pascal ICError ICCChooseConfig(ComponentInstance inst)FIVEWORDINLINE(0x2F3C, 0, 33, 0x7000, 0xA82A);/* See comment for ICCChooseConfig. */pascal ICError ICCChooseNewConfig(ComponentInstance inst)FIVEWORDINLINE(0x2F3C, 0, 34, 0x7000, 0xA82A);/* See comment for ICCChooseNewConfig. */pascal ICError ICCGetConfigName(ComponentInstance inst, Boolean longname, Str255 name)FIVEWORDINLINE(0x2F3C, 6, 35, 0x7000, 0xA82A);/* See comment for ICCGetConfigName. */pascal ICError ICCGetConfigReference(ComponentInstance inst, ICConfigRefHandle ref)FIVEWORDINLINE(0x2F3C, 4, 31, 0x7000, 0xA82A);/* See comment for ICCGetConfigReference. */pascal ICError ICCSetConfigReference(ComponentInstance inst, ICConfigRefHandle ref, long flags)FIVEWORDINLINE(0x2F3C, 8, 32, 0x7000, 0xA82A);/* See comment for ICCSetConfigReference. *//* ***** Private Routines ***** *  * If you are calling these routines, you are most probably doing something * wrong.  Please read the documentation for more details. */pascal ICError ICCSpecifyConfigFile(ComponentInstance inst, FSSpec *config)FIVEWORDINLINE(0x2F3C, 4, 3, 0x7000, 0xA82A);/* See comment for ICCSpecifyConfigFile. */pascal ICError ICCRefreshCaches(ComponentInstance inst)FIVEWORDINLINE(0x2F3C, 0, 47, 0x7000, 0xA82A);/* See comment for ICCRefreshCaches. *//* ***** Getting Information ***** */pascal ICError ICCGetSeed(ComponentInstance inst, long *seed)FIVEWORDINLINE(0x2F3C, 4, 4, 0x7000, 0xA82A);/* See comment for ICCGetSeed. */pascal ICError ICCGetPerm(ComponentInstance inst, ICPerm *perm)FIVEWORDINLINE(0x2F3C, 4, 13, 0x7000, 0xA82A);/* See comment for ICCGetPerm. */pascal ICError ICCDefaultFileName(ComponentInstance inst, Str63 name)FIVEWORDINLINE(0x2F3C, 4, 11, 0x7000, 0xA82A);/* See comment for ICCDefaultFileName. */pascal ICError ICCGetComponentInstance(ComponentInstance inst, ComponentInstance *componentInst);/* See comment for ICCGetComponentInstance. *//* ***** Reading and Writing Preferences ***** */pascal ICError ICCBegin(ComponentInstance inst, ICPerm perm)FIVEWORDINLINE(0x2F3C, 2, 5, 0x7000, 0xA82A);/* See comment for ICCBegin. */pascal ICError ICCGetPref(ComponentInstance inst, ConstStr255Param key, ICAttr *attr, Ptr buf, long *size)FIVEWORDINLINE(0x2F3C, 16, 6, 0x7000, 0xA82A);/* See comment for ICCGetPref. */pascal ICError ICCSetPref(ComponentInstance inst, ConstStr255Param key, ICAttr attr, Ptr buf, long size)FIVEWORDINLINE(0x2F3C, 16, 7, 0x7000, 0xA82A);/* See comment for ICCSetPref. */pascal ICError ICCFindPrefHandle(ComponentInstance inst, ConstStr255Param key, ICAttr *attr, Handle prefh)FIVEWORDINLINE(0x2F3C, 12, 36, 0x7000, 0xA82A);/* See comment for ICCFindPrefHandle. */pascal ICError ICCGetPrefHandle(ComponentInstance inst, ConstStr255Param key, ICAttr *attr, Handle *prefh)FIVEWORDINLINE(0x2F3C, 12, 26, 0x7000, 0xA82A);/* See comment for ICCGetPrefHandle. */pascal ICError ICCSetPrefHandle(ComponentInstance inst, ConstStr255Param key, ICAttr attr, Handle prefh)FIVEWORDINLINE(0x2F3C, 12, 27, 0x7000, 0xA82A);/* See comment for ICCSetPrefHandle. */pascal ICError ICCCountPref(ComponentInstance inst, long *count)FIVEWORDINLINE(0x2F3C, 4, 8, 0x7000, 0xA82A);/* See comment for ICCCountPref. */pascal ICError ICCGetIndPref(ComponentInstance inst, long index, Str255 key)FIVEWORDINLINE(0x2F3C, 8, 9, 0x7000, 0xA82A);/* See comment for ICCGetIndPref. */pascal ICError ICCDeletePref(ComponentInstance inst, ConstStr255Param key)FIVEWORDINLINE(0x2F3C, 4, 12, 0x7000, 0xA82A);/* See comment for ICCDeletePref. */pascal ICError ICCEnd(ComponentInstance inst)FIVEWORDINLINE(0x2F3C, 0, 10, 0x7000, 0xA82A);/* See comment for ICCEnd. *//* ***** User Interface Stuff ***** */pascal ICError ICCEditPreferences(ComponentInstance inst, ConstStr255Param key)FIVEWORDINLINE(0x2F3C, 4, 15, 0x7000, 0xA82A);/* See comment for ICCEditPreferences. *//* ***** URL Handling ***** */pascal ICError ICCParseURL(ComponentInstance inst, ConstStr255Param hint, Ptr data, long len, long *selStart, long *selEnd, Handle url)FIVEWORDINLINE(0x2F3C, 24, 16, 0x7000, 0xA82A);/* See comment for ICCParseURL. */pascal ICError ICCLaunchURL(ComponentInstance inst, ConstStr255Param hint, Ptr data, long len, long *selStart, long *selEnd)FIVEWORDINLINE(0x2F3C, 20, 17, 0x7000, 0xA82A);/* See comment for ICCLaunchURL. *//* ***** Mappings Routines ***** *  * Routines for interrogating mappings database. *  * ----- High Level Routines ----- */pascal ICError ICCMapFilename(ComponentInstance inst, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 8, 24, 0x7000, 0xA82A);/* See comment for ICCMapFilename. */pascal ICError ICCMapTypeCreator(ComponentInstance inst, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 16, 25, 0x7000, 0xA82A);/* See comment for ICCMapTypeCreator. *//* ----- Mid Level Routines ----- */pascal ICError ICCMapEntriesFilename(ComponentInstance inst, Handle entries, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 28, 0x7000, 0xA82A);/* See comment for ICCMapEntriesFilename. */pascal ICError ICCMapEntriesTypeCreator(ComponentInstance inst, Handle entries, OSType fType, OSType fCreator, ConstStr255Param filename, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 20, 29, 0x7000, 0xA82A);/* See comment for ICCMapEntriesTypeCreator. *//* ----- Low Level Routines ----- */pascal ICError ICCCountMapEntries(ComponentInstance inst, Handle entries, long *count)FIVEWORDINLINE(0x2F3C, 8, 18, 0x7000, 0xA82A);/* See comment for ICCCountMapEntries. */pascal ICError ICCGetIndMapEntry(ComponentInstance inst, Handle entries, long index, long *pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 16, 19, 0x7000, 0xA82A);/* See comment for ICCGetIndMapEntry. */pascal ICError ICCGetMapEntry(ComponentInstance inst, Handle entries, long pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 20, 0x7000, 0xA82A);/* See comment for ICCGetMapEntry. */pascal ICError ICCSetMapEntry(ComponentInstance inst, Handle entries, long pos, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 12, 21, 0x7000, 0xA82A);/* See comment for ICCSetMapEntry. */pascal ICError ICCDeleteMapEntry(ComponentInstance inst, Handle entries, long pos)FIVEWORDINLINE(0x2F3C, 8, 22, 0x7000, 0xA82A);/* See comment for ICCDeleteMapEntry. */pascal ICError ICCAddMapEntry(ComponentInstance inst, Handle entries, ICMapEntry *entry)FIVEWORDINLINE(0x2F3C, 8, 23, 0x7000, 0xA82A);/* See comment for ICCAddMapEntry. *//* ***** Profile Management Routines ***** */pascal ICError ICCGetCurrentProfile(ComponentInstance inst, ICProfileID *currentID)FIVEWORDINLINE(0x2F3C, 4, 37, 0x7000, 0xA82A);/* See comment for ICCGetCurrentProfile. */pascal ICError ICCSetCurrentProfile(ComponentInstance inst, ICProfileID newID)FIVEWORDINLINE(0x2F3C, 4, 38, 0x7000, 0xA82A);/* See comment for ICCSetCurrentProfile. */pascal ICError ICCCountProfiles(ComponentInstance inst, long *count)FIVEWORDINLINE(0x2F3C, 4, 39, 0x7000, 0xA82A);/* See comment for ICCCountProfiles. */pascal ICError ICCGetIndProfile(ComponentInstance inst, long index, ICProfileID *thisID)FIVEWORDINLINE(0x2F3C, 8, 40, 0x7000, 0xA82A);/* See comment for ICCGetIndProfile. */pascal ICError ICCGetProfileName(ComponentInstance inst, ICProfileID thisID, Str255 name)FIVEWORDINLINE(0x2F3C, 8, 41, 0x7000, 0xA82A);/* See comment for ICCGetProfileName. */pascal ICError ICCSetProfileName(ComponentInstance inst, ICProfileID thisID, ConstStr255Param name)FIVEWORDINLINE(0x2F3C, 8, 42, 0x7000, 0xA82A);/* See comment for ICCSetProfileName. */pascal ICError ICCAddProfile(ComponentInstance inst, ICProfileID prototypeID, ICProfileID *newID)FIVEWORDINLINE(0x2F3C, 8, 43, 0x7000, 0xA82A);/* See comment for ICCAddProfile. */pascal ICError ICCDeleteProfile(ComponentInstance inst, ICProfileID thisID)FIVEWORDINLINE(0x2F3C, 4, 44, 0x7000, 0xA82A);/* See comment for ICCDeleteProfile. *//* ***** Interrupt Safe Routines ***** */pascal ICError ICCRequiresInterruptSafe(ComponentInstance inst)FIVEWORDINLINE(0x2F3C, 0, 45, 0x7000, 0xA82A);/* See comment for ICCRequiresInterruptSafe. */pascal ICError ICCGetMappingInterruptSafe(ComponentInstance inst, Ptr *mappingPref, long *mappingPrefSize)FIVEWORDINLINE(0x2F3C, 8, 46, 0x7000, 0xA82A);/* See comment for ICCGetMappingInterruptSafe. */pascal ICError ICCGetSeedInterruptSafe(ComponentInstance inst, long *seed)FIVEWORDINLINE(0x2F3C, 4, 48, 0x7000, 0xA82A);/* See comment for ICCGetSeedInterruptSafe. *//* ¥¥¥End ICCAPI.h¥¥¥ */#ifdef __cplusplus}#endif/*#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif*/#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#endif